\subsection{SYSTEM MODEL}
(what the simulation can do)
- a discrete event simulation
1. what is this simulation model
2. why it has been picked this model

The simulation is discrete event simulation system that processes the sequence of event and each execution of the event may lead to the change of system state. Since the events of distributed algorithm are discrete, and the number of states is finite, at any given point in time the state of the system can be observed, therefore, discrete simulation has been used. The simulation consists of three main components are internal clock, event list and number generator.

Internal clock represents a simulation time that keeps track of current times of the simulation and make sure the time is advancing. Any new event created will be assigned an execution time that will be after a current simulation time.

Event list is an ordered list of discrete event of system model ordered by simulation time. The event is an instantaneous action that occurs at a given time. After the event has been executed the system may changed the state and/or derives another set of event.

Event generator generates the events corresponding to user algorithm in order to simulate the behavior of the algorithm. Each event derived from that execution of previous event, but each execution of event may not always create event or list of event in order to provide a mechanism to terminate the simulation.


- required a single machine to operate
1. what are the advantages of this simulation model
2. what are the disadvantages of this simulation model

The simulation runs on a single machine and it will simulate multiple virtual machines and connected into a network topology based on user predefined in graph editor. The virtual machines created are homogenous in term of computing power and algorithm that runs on it. The simulation allows user to define the distributed environment into the network such as network communication (i.e. connectivity, delay time and reliability), power consumption and mobility ability. These environment parameters can be defined before or during the simulation execution, which in a real network these parameters are not easy or impossible for user to define or adjust in order to test the algorithm. In addition, the cost and complexity of setting up the network topology in different structures are expensive and troublesome in real network, while in our virtual are done with ease in minutes.
The limitation of creating virtual network in a single machine is the size of network which completely realize on a power and memory size of the machine. Also the network can only create a set of homogenous virtual machine; it cannot create a network that contains varieties of machine with different properties and algorithm.


- support message passing and distributed agent computing
	- direct message passing
	- whiteboard
	- token
1. what are communication models support by this simulation
2. why these communication models were picked
3. what was communication models were not picked
4. what are the differences between these models (in brief)
5. when these model will be used

The simulation supports four types of distributed communication model, the first model is message passing and the other three are used in distributed agent computing are blackboard, whiteboard and token. These four models are common model used in distributed computing each model has advantage and disadvantage on itself based on nature of task it is performing.

Direct message passing model is a distributed system that allows the node in the network to share information by sending and receiving message between each others. The node in the network has completely no visibility and knowledge of others except by the information received.

Blackboard, whiteboard and token are different than direct message passing in term of communication because it is used for mobile agent platform, which there will be a set of agent that traveling between nodes in the network while message passing are not. The agents actions are asynchronous, have it own memory, and capability of computing task on a node.

Blackboard model is a system that each node provides a sharing memory area (blackboard) that allows the visiting agents to read and write the information into it. The blackboard information is completely visible locally within a node that hosts it, in order for any agent to read or write the agents must present inside the node. For writing access, the blackboard provides a mutual exclusive access to an agent once at a time, while reading can be done by multiple agents at a time.?????

Whiteboard model is a similar system to blackboard except the information on a board is propagates to every node in a network. The visibility of information of a whiteboard can be seen at any node in a network.???

Token or Pebble is a model that allow agent to carry some amount of token and a node allows the agent to drop/pick  token at/from various place within the node. The token can be replicated or destroy during the execution of protocol by agent or node.



- various network model
	- fixed
	- dynamic
	- mobility
1. what are network models support by this simulation
2. why these network models were picked
4. what are the differences between these models (in brief)
5. when these models will be used
6. how these models are used

The simulation supports three types of network models, fix, dynamic and mobility. By definitions the network or topology is a set of nodes that formed up into a group and connect to each others by a means of communication medium such as fiber optic, wireless antenna, satellite etc. the node in these three networks are homogenous in term of computing and program that installed. These three networks are common use in the real world of industries and academic researches.

A fixed network is a network of fixed and wired connection between nodes, the communication on a link can be uni-directional or bi-direction. The nodes are totally independent from each others but they are homogenous.

A dynamic network is similar to a fixed network but the difference is that in dynamic network the connection between nodes can be changed at any given time such as a link between nodes in the network can be dropped or resurrected. Also the node can be removed or added into the network while the simulation is running.

A mobility network is a set of nodes that can move and has wireless connection, the connectivity within the network determined by the range of wireless transmission between nodes. Therefore, the structure of the networks is constantly changed if the nodes are constantly moving.

These three models are common network structure in distributed computing studies and in real life applications. Therefore, the simulation can support the development of algorithms that have been developed for these three network models. The very good examples of situation or applications that are used in fixed network model are parallel computing, LAN/WAN network maintenance and routine tasks etc. in dynamic network model are internet cloud computing, sensor network that detect geographical changes, LAN/WAN network maintenance and routine tasks etc. and in mobility network model are mobile sensors network that detect geographical changes, mobile communication network like cell phone etc.


- support GUI
	- topology editor
	- java programming IDE
	- simulation controller
    - viewers
1. what are GUI functionalities that the simulation provided
2. why does simulation support only these gui functions
3. what GUI functionalities the simulation not support and why

The simulation provides four main GUI, Java IDE, graph editor, simulation controller, and viewers. Java IDE is a very powerful tool that DisJ derived from Eclipse IDE and has been used by many hi-tech industries for developing Java software. The graph editor allows user to create and edit topology manually from drawing nodes and connecting links between them, or using topology wizard creator that automatically draw a well-known topologies by a click of button. The simulation controller provides interface for user to control an execution of the simulation from loading algorithm to replay of saved execution. The viewers provide different types of view such as Node View, Agent View, Statistics View, Properties View etc in which allow user to observe runtime statuses, behaviors of the algorithm and statistics data of different entities and perspectives.

These four main GUI cover a full life cycle of software development from writing a code to verifying correctness and performance, which it is definitely increase effectiveness to user in developing a reactive distributed algorithm. However, there can be others more GUI to add on but these four GUI are effectively sufficient enough.

Currently version has not yet supported GUI for Adversary execution control, topology debugger and multi type viewers from statistical reports. However, these will be add in further development.

- using JAVA as user development protocol
1. how does the simulation has been developed
2. why use this methodology in development
3. what advantage/disadvantage of this strategy of development
4. what are the difficulties in development

DisJ simulation has been fully developed as Eclipse plug-in application by using Java technologies. Eclipse is an open platform that is designed for third parties to develop and extend their software by reusing existing resources provided by Eclipse platform to their software. Eclipse is a collection of a small program that collectively run and consume services from each others to achieve a goal of the third party software, this small program is called Eclipse plug-in. In our case, we develop a DisJ simulation for reactive distributed algorithm which requires many existing plug-in such as Core plug-in, JDT plug-in, UI plug-in and GEF plug-in, Team(Concurrent and Version Control) plug-in etc.

The simulation has been designed with Object Oriented methodology which allows the software to adopt properties of Object Oriented such as modularity, adaptability and reusability. Since, the simulation can be improved in many aspects in the future therefore, these properties of software are crucial for enhancement and maintenance with less complexity and resources. However, the difficulties of design and development of the simulation are creating API set that can fulfill future needs of changes and add on.

The simulation provides various type of communication API set of three different models, in which it is a main interface for user algorithm to communicate and interact with the simulation. Since there are many models and layers of communication in distributed computing that DisJ supports therefore, it is very hard to define the set of API that answers all the needs and avoids any confusion in using it.

The others difficulties are in software engineering domain which we all known and is a key issue to every software development project, adaptation for a future changes. Since the future needs and requirements are unknown so, the designers have to predicted the possibilities and pin down the sections of software that may be changed and design those sections with high flexibility. However, the other sections that were not selected still cannot be overlooked therefore flexibility still apply to it as well. The most challenging in creating adaptability software that is ready for future requirements, and the later challenge is a penalty that the software has to pay for adaptability such as performance, size of code and complexity of design etc.


- provide API for distributed communication
1. what main tools are provided for user to develop protocol
2. why does the simulation provided only this set of tool
3. what are not provided and why

There are three models that the simulation supports, message passing, agent with whiteboard, and agent with token models.

Message passing model is a communication model for nodes communication, the nodes communicate to each other by sending and receiving messages via a communication medium (wire or wireless), any information of a node can only be shared to other nodes via messages.

Agent with whiteboard model is a communication model for agent that moving from node to node within a connected network, the agent can communicate to each other by writing and reading message to/from the board that hosted by a node in the network, any node information can be directly accessed by an agent while it resites at the node.

Agent with token model is a communication model for an agent that moving from node to node within a connected network, a token is a small number of bits that agent can carry. Every token are identical and undistinguishable, the number of token that agent can carry and ability of replicate/destroy token have been defined by environment before an execution begin. Agent can drop and/or pick up token(s) at a node and agent can access node information once it resites at the node.

These three models are common and well known in distributed computing and there are many existing algorithms that use these models. (example of protocol using each model)????

Face to face communication of agent has been left out due to it is not yet commonly use in distributed computation and there are no (yet) existing common definition of the communication such as the location of meeting (at a node, on a link), the distance between agents that can be defined as meeting, and direction of agent facing etc. Therefor DisJ has not yet support agent to agent communication but not limited to for future improvement.


- external plug-in libraries
	- probability model
1. what are flexibility of the tool provided to user
2. what are advantage/disadvantage of this flexibilities
3. what is not include or support and why
4. how it has been use (in brief) how easy is it
5. what are limitation

As part of our adaptability to user libraries, the simulation provides a channel to accept or link user libraries into the simulation. The current channel we accept are probability model libraries which is used in generate random result such as probability of losing message on a link, a time length that agent probably will spent in traveling on a link etc.

Probability model, currently the default probability model used by the simulation is random uniformed. In some cases, user might have their probability model that fit best for their simulation protocol, therefore the user can set the simulation to use their model instead of the default model.

Custom communication model libraries which is not yet support because communication is the most important means of the existing of distributed computing. Therefore, a small change of character of communication it will completely define a new type of distributed computing, which mean it is very difficult to design software to adapt functionalities that unknown of its character and it will definitely require difference underline infrastructure. For example a visibility of information on a whiteboard, currently visibility of whiteboard is local at a node that host it, if another model allows global visibility of the whiteboard which mean global synchronization and notification of nodes and agents have to be handled and underlining infrastructure has to be redesign in order to adapt such API from custom communication model.

In order to plug-in custom probability model library, user has to implement interfaces that DisJ requires in class IRandom, so that DisJ will call those functions in IRandom when it needs, and user implemented interface will redirect the call to custom libraries correctly. However, before the execution of the simulation, user has to load the implemented interface to the simulation by click load random library button on DisJ editor.

Limitation for external libraries API with respect to the simulation is that the implemented interface class has to be Java language only, if the existing libraries are others languages rather than Java, then user has to use Java technologies to communicate to the libraries from implemented interface class. For example, if existing libraries are C/C++, user may use JNI or socket to communicate.



- runtime interaction to the program

1. what functionality is used for user interaction with the simulation
2. why these functionalities are picked
3. what are limitations

DisJ simulation provides visualization views and controls during runtime execution and replay. For the control execution, the simulation provides Start, Pause, Resume, Step Next, Adjust Speed and Stop functions that user can interact via GUI. The simulation also provides many types of view that user can observe and some can be interacted, for examples Properties Views that allow user to view and interact such as viewing entity properties, modify some properties of entities (changing port label, adjust reliability of link etc). Agent View display status and location of each agent, Node View display status and internal info (whiteboard data, number of token located etc). Finally, Statistic View display report charts of interesting info (number of agent corresponding to agent's states, number of messages sent corresponding to each of node state etc)

These runtime interactions allow user to interact and observe a closer look of behavior of algorithm during the execution of the protocol. Also provides information that may help user to have a better analysis of the algorithm at different stages of protocol execution.

However, the simulation has not yet supported hot codes replacement, which mean the modification of algorithm during the execution does not effect results of execution until user stop the simulation, reload algorithm and restart the simulation execution.


- replay execution
1. what is replay
2. why we need it
3. how does it work
4. what is limitation

Replay execution is a visualization of replaying a saved execution data. The visualization display, entities states transition, and statistics results are exactly the same as what happened during the execution.

Replay execution provides a way for user to observe a past execution of algorithm in off-line mode and in a closer look in such a way that the behavior of execution will be the same regardless or number of times user rerun the replay. Sometime, user algorithm is based on some random decision or based on a curtains set of states transitions that cause failure of the algorithm. Therefore, user can observe and find reasons of the failure without reliable on random chance or rerunning the execution so that the algorithm will have the same set of states transitions of the past failure execution.

Every execution of the simulation, DisJ simulation will automatically save all necessary information that requires for replay of the execution in a persistence storage, e.g. file I/O, in redefined text format. Therefore, the Replay will read a saved file that provided by user and reproduce a visualization of execution as if it was executing algorithm but it is not.

The replay execution is 100 percent readonly execution therefore, any adjustment of input into the replay via GUI will not effect any of executions. Also the save file will be saved under .rec file extension and the name of the file will be the name of a topology file, thus, any execution on that topology file will cause an overriding .rec file, therefore, it is user obligation to rename the .rec file if user willing to save it for later replay.





- hidden OSI network layer and below
- network environment control
1. what special feature about this features to user
2. what these special features do

 DisJ simulation provides a set of communication API for user protocol that hide the detail of network communication and its layers below. The advantage of this API is to allow user to focus on an algorithm of protocol instead of coding detail of communication, since the layer below are technology, environment and hardware specific in which, most likely, independent from the algorithm of the protocol. Also the complexity of communication coding is a complex issue by itself in which it should not be mixed into a distributed algorithm development. For example for message passing model, the simulation provides an API function call to broadcast message to all neighbors that connected to the sender. This function call will handle the transportation in finding the neighbors and deliver the message to a right recipients.

 The communication  properties like delay, losing and order of message arriving during the transmission will be handled by the simulation based on the parameters configurations. These communication properties setting are powerful features that allow user to create and control the prefer environment of the network communication in order to test and verify the protocol. Contradiction to the real network that user hardly be able to control and it is difficult to test and verify the correctness and performance of the protocol.


- provide statistic record of algorithm execution
1. what stats and report does the simulation support
2. what does not support
3. what are limitation and future potential

The statistic and record keeping of the execution of protocol states is another tool that help user to analyze the protocol correctness and performance. The basic information that the simulation currently provide are related to resource usage, communication usage, and unit execution time. These reports are related to node and agent that are used in the execution of protocol, also the report will produces any interested relationship between entities, status and environment etc. Examples of direct information collected relate to node are number of message sent/received, type of message sent/receipted, target and source of message transmission etc, and examples of relation information collected relate to node are number of messages had been sent during certain states, number of nodes that were at curtain states, type of message produces at curtain node state etc.

In term of reports and statistics, there are limitless to present data in difference perspectives while DisJ capture only some of it, however, DisJ saved all raw data from an execution and user may do mining it in later time in order to get preferred dimensions, also DisJ will leave to future improvement.

// NOT SURE YET THAT WE NEED
//==========================
- persistence storage of data in file system
	- replay log data
1. what persistence features provided by the simulation
2. what does not
3. why these were pick, advantage/disadvantage
4. what limitation and future potential

Some of the simulation features and functionalities that described above are not be able to exist without the use of persistence storage. Therefore, the persistence is worth to describe a bit in order to justify the usage in those features. The simulation will keep three main types of record in persistence are logging, statistic data, and states transition which currently are kept in a file system format.

Logging data includes internal logging of the simulation that will be used to find defections or study of the simulation behaviors and performance. For external logging from user (do we need it) ????

Statistic data and records are also kept in the persistence storage and being used to make a report of the execution.

State transition records are kept and used for replay the simulation, since the replay is a visualization of past execution, which there is no new execution being made to the protocol. The replay is a recreate of visualization based on the state transition records and information kept by the simulation.


- limitation
	- size of network
	- environment configuration i.e. visibility setting, communication range etc.
	- underline communication cost
1. what are the limitation of disj simulation
2. why don't support it
3. how these can be overcome

DisJ simulation is at early stage, therefore there are many limitations and incomplete features but it has provided, at some level, a satisfaction to support user in development of distributed protocol. The most common limitation is the size of network which are completely based on performance of a machine that runs the simulation. Secondly, the environment parameters configuration that the simulation currently supports are limited due to time of development but definitely it can be added and improve in the future. Third, the underline communication cost that has been hidden to user, which in the real world environment, this cost cannot be neglected and it is necessary to include in protocol analysis. In the real world, it is very difficult to measure the cost because it is very tight to specific technology proprietary, size of network, and environment specific; the actual value are highly deviated based on many factors and never be the same for each execution of the protocol. However, the simulation main objective is to help user to develop the protocol and verify it correctness and its performance, not to verify the performance of the network that it has been deployed.


DisJ core system is divided into 4 logical sections
1. Communication
2. Runtime
3. API
4. Usage of Simulation

1. what are the core of this thesis
2. why it has been divided into this way

The main proposal of the simulation for distributed algorithm is to purpose an effective software program that allow user to develop a distributed algorithm protocol at maximum efficiency with ease of usage at low cost. The simulation are consisted of four main categories: Communication model of distributed computing that the simulation supports, Runtime execution of the protocol by the simulation, API that the simulation provides and supports, and user interaction and usage of the simulation that will be discussed in the following sections


\subsection{COMMUNICATION}

This section defines distributed communication models between entities in the system
1. what is communication
2. what is it for
3. why need it
4. what communication the simulation supported
5. how the simulation support it
6. what are the differences

In distributed computing, entity cannot have direct access to other entities information, in which it has to communicate in order to exchange information. The communication between entities in a connected network is a way to obtain information of other for internal computing and for collaboration of a task that entities are trying to achieve. The simulation supports three common distributed communication models that are used in distributed computing: message passing, agent with whiteboard and agent with token. DisJ has implemented these models and hide the complexity from the user by providing a set of API of each model for programming. The behaviors and characteristics of each communication model are described as follow:

Message passing model is a model that a node can send/receive message to/from any nodes that are connected. Message is a finite sequence of data that have a format that known by nodes in order to read/write. The message is transmitted via a medium (cable link, wireless wave etc) that carries message from source to destination. The reliability and order of message transmission are depended on the medium conditions.

Agent with Whiteboard model is a model that has two types of entities: node and agent. The communication between nodes(for now) is has been used for infrastructure and network maintenance purpose only. Agent, a main entity that perform tasks in this model, has whiteboard as a communication medium between agents, which they can read, delete and write information on the board. The boards are located at each node and have mechanism that controls multi agents access. The communication between an agent to a node is direct access via provided API while it resites in the node.

Agent with Token model is also a model that has two types of entities: node and agent. The communication between nodes(for now) is has been used for infrastructure and network maintenance purpose only. Token is a small piece of fixed data, and every tokens are identical and undistinguishable by any entity. Tokens can be created and destroyed by agent, the token can be dropped or pick up at a node by agent, however, user can set limitation of token creation and number of token agent can carry. Agent can communicate to other agents by dropping off or picking up token(s) at a node based on user protocol. The communication between an agent to a node is direct access via provided API while it resites in the node.

In order to support these models the simulation has divided the underneath communication platform into three sub-modules that implements each model. Each module will be activated based on user selection at the beginning of protocol development. The behaviors and functions of each model are described as followed

\subsubsection{3.2.1 Message Passing Model}

- definition
1. what is it
2. what is important things for this model

Message passing model in distributed computing based on a communication method where messages are sent and received between entities via a medium of transportation(cable link, wireless wave etc). In message passing model, entity has no other means of communication or access others entities information but via send and receive message. Each message drives entity that received the message to perform actions based on the content of the message, current state of entity and the protocol algorithm.

Therefore, a transportation of message is very essential factor that defines the complexity of the protocol beside the content of message itself. There are several properties that relates to the transportation in which DisJ considers as important for development of the protocol such as reliability, order of arrival, synchronous/asynchronous, duplex/half-duplex etc. The following subsections describe each properties that DisJ currently supports

- properties cover
	- synchronous/asynchronous
	- delay time
	- reliability rate	
	- local orientation
	- uni-directional/ bi-directional
	- order of arrival

1. what properties are covered
2. why these were picked and important
3. how these properties effect the simulation and user
4. case study

\begin{description}
\item[Reliability Rate]
This defines level of reliability of message transmission on a link that will be reached destination in finite time from total reliability to always loss.

The reliable of message is a very crucial property in any distributed computing model since the communication drives actions of entities. Any missing of message may skip some actions, and skipping some actions may leads to a failure of a protocol. The missing of message may also increase the number of message to resend if protocol has a detection mechanism, in which it will lead to the performance draw back and traffic intensity in a network. In addition, any real network there always a loss of message in transmission from various causes such as power failure, nature disruption, limitation of hardware etc. therefore, the simulation has to provided this option for user to duplicate the real network environment and able to test a protocol to handle such conditions.

DisJ simulation provides a parameter configuration for reliability rate by allow user to input probability number between 0 to 100 inclusive, and the simulation will use, by default, uniform random probability generator to generate probability of success of each and every message before it has been sent.

For example, neighbor information collection protocol, the protocol is simply broadcast their information to every directed connected neighbors, and keep tract that it has received message from every of its neighbors, then terminated. This protocol works nicely if the message is total reliable, however, if it is not total reliable, the protocol will be a lot more complex just to make sure that it is it is correct.


\item[Delay Time]
This defines a finite time that message requires to travel on a link between directed connect pair of source and destination.

A message traveling time on a link is based on many factors such as the medium of transmission, hardware, nature disruption etc. The delation of messages may cause the performance draw back or even failure of the protocol, since an entity may not be able to perform some actions without arrival of message -- cause to postpone the actions. In addition, message delay may cause the order of execution of protocol when message from different sender arrived before another in which may cause the failure of protocol.

DisJ simulation provides this option for user to set a finite time on target links or every links in a graph. The input is a positive integer which refer to as a simulation time unit that user wants every message traveling through the target links will take.

For example, a spanning tree construction protocol, the protocol is to construct a virtual tree structure network. This protocol is initiated by a single node (which it can be many nodes) broadcast a message to all neighbors, then become passive and root of a tree. Any other nodes that received a message for the first time, it will set a sender of the message to be its parent, then broadcast the messages to all others. Once a node is in a passive state, it ignores every message that received. This protocol will create different tree at each execution due to the arrival of a first message to a node will dictate the parent. Therefore, the delay on the link will definitely affects the structure of a tree and structure of a tree defines an efficiency of tree's properties.


\item[Order of Arrival]
This property defines order of arrival of message traveling in a link in order to arrive at destination in specific order e.g. FIFO, LIFO or Random.

A node may send a sequence of message on a same link and a receiver node may receive messages in difference sequence which can alternate the sequence of action of a receiving node. Therefore, order of message arrival may cause a draw back of performance or even a correctness of a protocol. In a real network the order of message arrival may varies at any point in time due to many reasons such as hardware, internal implementation of transportation, traffic condition etc. Therefore, the simulation provides an option for user to alternate the behavior of message arrival in order to test and verify the protocol correctness and performance.

The simulation support three common types are FIFO, "First In First Out", where the message will be arrived in an order as when it sent. LIFO, "Last In First Out", where the message will be arrived in reverse of the time it sent. Finally, Random, where the message will be arrived in random order from where it sent, the simulation uses uniform random probability to assign the arrival sequence of messages on a link. These property can be set individually on a link or as globally to every link in a graph.

For example, message construction protocol, this protocol is very common in internet communication when the file is too big and it has to be sent in multiple small messages. The sequence of arrival define complexity of the protocol on how to construct an original message. If it is FIFO, the destination only has to append a message to previous messages until the arrival of termination message. While in random the sender may have to add extra information to each small message in order to help the destination construct the message (i.e. sequence number). Moreover, it is even more complex when the termination message arrived before all small messages have been received. Therefore, the order of arrival is very crucial environment for user to test and verify the protocol correctness and performance.


\item[Synchronous or Asynchronous]
This property indicates the execution and transmission of every messages and entities in the network that can be synchronous or asynchronous.

In distributed computing there are two common environments of computing, synchronous and asynchronous which strongly dictates a protocol of how to solve a same problem in difference way, some problems may be easier to solve in one environment than another.

Synchronous environment, where entities have a same internal synchronous clock that synchronously run, and the transmission of messages are synchronously transmitted in every link within a network. Therefore, a protocol can make use of these two properties, which are common knowledge to every entities to control the time of execution and message transmission.

Asynchronous environment is the environment where entities have difference internal clock and it is independent. The entity also has no knowledge of others clock, and any message transmission is not synchronously transmitted, which it can happen at any given time by an entity. Therefore, a protocol cannot realize on internal clock and time as synchronous environment.

The simulation has internally implemented the internal clock and message control, and it provides options for user to select the type of environment. The synchronous environment option will allow entities to perform task synchronously across the network, and message transmission will be strictly synchronous. The simulation also provides an API to (readonly) access internal clock and current time of the simulation in every entity.
While the asynchronous environment the simulation does not control the synchronistic of entity internal clock, the current simulation time of each clock will be difference. Messages transmission are not synchronously control by the simulation, therefore, at any point within an interval of simulation time unit, messages may be transmitted.

For example, broadcast info with global termination protocol, this protocol has a simple objective is to broadcast info to all of its neighbors then terminate globally. The assumptions are network is total reliable, and knowledge of network diameter. In synchronous network, every node flood messages and wait for a diameter unit of time then terminated. During the waiting entity may receive or send message. After the diameter unit of time, every node will terminate and know that it is a global termination because the longest time for a message to be flooded in the network from on end to another end is a diameter time units. In asynchronous network, it is more complex and requires extra works more than synchronous environment such as leader election to coordinate global termination.


\item[Type of Link]
This property defines the link communication pipe whether to be bi-directional or uni-directional.

There are two types of link, uni-directional and bi-directional. Uni-directional or half-duplex, is a link that has one way message transmission such as a uni-directional link between A and B, let say link A-B, which a message can be sent from A to B but not from B to A. However, B can have a uni-directional link and send message to A as well, let say B-A. These two links are physically separate and totally independent from each other, therefore, if one link was down the another may still alive. In Bi-directional or full-duplex, is a link that has two ways message transmission such as a bi-directional link between A and B, let say link A-B, which a message can be sent and received from the same link and it is a physically share between two directions. Unlike uni-directional, if the link is down, both ways of communication will be down and the environment properties are subjected to impact to one and another e.g. pay load and traffic congestion etc.

In the dawn of network infrastructure, the cost of building full-duplex is very expensive and high complexity of implementation in physical and data layers. Therefore, the existing of half-duplex link are famously used in the early day, however, there still existing half-duplex in many network today even the cost full-duplex are low and the efficiency is high. For example, in high security network where information are critically confidence or mobile agent the has very limited of power consumption, therefore, uni-directional link are still around and used in many distributed algorithm protocol, but may not as much as bi-directional link.

DisJ simulation provides a graph editor that has two options for users to create a link in their virtual network, and the simulation will perform accordingly while the protocol is executed. The simulation physically provides two ports for a bi-directional link, in-port and out-port, automatically and one port for uni-directional (in-port or out-port) based on direction of the link. The simulation also keeps track of each and every entity's ports and provides API for user to access the record information (port list). If users are using non-existing port in their protocol, such as sending out message on a non-existing out-port, the simulation will throw an error exception in output console.

For example, Election in a ring protocol with unique ID, this protocol works for both uni-directional and bi-directional ring, by each node flood message with it ID, and the message will be relayed if the ID in the message is smaller than the receiver ID. The message of smallest ID will travel around the ring and return to the message originator. Notably that this protocol uses less number of messages in uni-directional ring than bi-directional ring. Therefore, both types of links are useful and have advantages than another based on various conditions e.g. network, protocol etc.


\item[Local Orientation]
This relates to port labeling of nodes within a network the knowledge of port labeling is local to the node only. Therefore, the duplication of ports label can happen within a network but not in a node. However, the label of incoming port and outgoing port can share the same label, which by default DisJ provides the same label for incoming and outgoing ports of bi-directional link.

Local orientation has a high effect to the complexity of distributed computing protocol because the protocol can realize on the port labeling and save time of computing and memory usage. Therefore, in real network there usually have a virtual network with a proper labeling that help reduce complexity and cost of protocol. For example, a virtual tree network, spanning tree, since tree structure has many properties that facilitate and reduce the cost of communication and information access. Therefore, the labeling of the port that help protocol to fine which port is heading to parent and children is unavoidable in order to make create a spanning tree network.

The simulation allows user to edit a port label manually from graph editor, however, by default the simulation always create a global unique port labels by using an edge ID, edge ID is an internal unique ID that assigned to an edge in a network, that connected to. For example, node 'A' connect to node 'B' with bi-directional link, so, port label of 'A' on the link will be 'b' and port label of 'B' on the link will be 'a'. In addition, the simulation does not allow a node to have more than type of link connection on a same pair, for example, 'A' connect to 'B' with a bi-directional link and 'B' cannot connect to 'A' with another bi-directional link. If 'A' connected to 'B' with uni-directional link, so 'B' still can connected to 'A' with another uni-directional link or bi-directional link, but not 'A' connect to 'B' with another uni-directional link nor bi-directional link. Also the simulation provides an option for user to create global oriented labeling to some topologies e.g. Ring, Torus, Tree, and Mesh, which the ports will be labeled globally the same way, for example in Ring, ever node will be connected to each other with Left port to Right port.

A classic example network with local orientation is a ring network with bi-directional link, where each node will have two ports called left and right. If every node defines their right port connects to a next neighbor left port this will automatically provide a global sense of direction of the network. Therefore, a protocol can make use of port label in order to make the protocol more efficiency. Moreover, in this example, the protocol can treat this bi-directional ring as uni-directional ring by define the protocol to send message only through a left port and receive from a right port, so, the protocol can switch between them back and forth based on the task that best suit them.




\subsubsection{3.2.2 Agent with Whiteboard Model}

- definition
1. what is it
2. what is important things for this model

Agent with whiteboard model is a distribute computing model that protocol is based on moveable agent, software entity, that can travel within a connected network. The agent may have some memory storage for self computing, and it communicates to others agents via whiteboard that located inside a node. The board is a bounded memory storage with a fair mutual exclusion access, which resides in a node (host) and allows visited agents to write, read and delete information on the board. The board can be accessed if and only if agent resides within a node, and the visibility of the board is local to the node only.

This mobile agent is a popular distributed computing paradigm in networked environments ranging from Internet to Data Grid where traditional computing is difficult to perform. For example, in maintaining and updating software of machines (nodes) in the network that physically located in difference locations, the agent can travel to each location and update software instead of human physically travel and perform a task.

Therefore, the simulation has provided the following properties that DisJ focus and currently supports and allows user to adjust in order to test and verify their protocol correctness and efficiency.

- properties cover
	- mutual exclusion access fairness rate (NOT yet support for custom adjustment)
	- size of board memory (unlimited)
    - notification of board to local registered agents

1. what properties are covered
2. why these were picked and important
3. how these properties effect the simulation and user
4. case study


\begin{description}
\item[Mutual Exclusion Access]
Mutual exclusion access control is a mechanism that controls agents in order to access whiteboard, the mechanism is not only control the integrity of data on a board but also the fairness accessing.

The mutual exclusion access control is very important sice it defines the correctness of the model infrastructure, if the infrastructure is false, then the development of protocol cannot be performed.

The simulation currently supports fully fairness mechanism by default and not yet allow user to adjust the fairness rate.

For example, Cautious Walk protocol is a protocol that used for Black Hole search in a network. An agent has to post a message that contains a status of this node and a target port for a next search on a board before heading to, so that another agent may acknowledge and prevent unnecessary actions. If the mutual exclusion access neither is unfair nor exists, the protocol may fail or leads to a high cost of computing (lost of agent in a black hole, unbalance workload of agent etc.)


\item[Memory size of Whiteboard]
Whiteboard is a bounded size of memory that store within a node (host). The size of memory that can be kept on a board is depended on the capacity of a node. The more information means more cost for a node in term of memory size and maintenance, but it may increase the efficiency of protocol and agent in performing a task.

Whiteboard in this model is the only means of communication between agents, therefore, the more communication agents need the size of memory requires for whiteboard is required.

The simulation currently (by default) supports unlimited number of post can be posted on whiteboard, and each post can be unlimited number of string of characters.

Example ???

\item[Notification of Access]
The node allows agent that resides in itself to register its whiteboard access activities by others agents e.g. write and delete. The node will inform a registered agent corresponding to the type that interested in when the access happening.

This notification of access allows agents to wait and see the information from others agents on a node before it perform some actions.

The simulation currently supports three types of notifications, board updated, an agent arrives at node, and an agent leaving the node. User can register the notification via API during the development of protocols, and there can be only one type each of notification can be registered, if user accidently repeatedly register the same type more than once, the simulation will simply ignore it, however, we courage user to handle it properly. Also, the registration will be automatically removed from a node once the agent leaves the node, but we courage user to unregister the notification when it does not needed.

Example ???


\subsubsection{3.2.3 Agent with Token Model}
- definition
1. what is it
2. what is important things for this model

Agent with Token model in distributed computing is a lest powerful model compare to Whiteboard. Agents communicate between each others by dropping and picking up tokens at a node. A token is an identical and indistinguishable bit of information that can be placed at the node. The visibility of token is local within a node, and the picking up a token is a mutual exclusive at each location. However, currently DisJ simulation does not support enhance token model which agent has capability to duplicate and destroy tokens, capability of dropping and picking up tokens on a link and at difference location inside a node e.g. in front of particular ports.

Agent with Token model is a cheapest cost of computation in distributed computing but every powerful and commonly used in some areas of applications such as security controlling access to certain resources in network, farness control of resource usage in network etc. This model heavily depends on management of tokens in network systems to make sure the integrity of tokens are preserved based on the requirement of the system. Therefore, DisJ simulation has provided the following properties of token that allows user to adjust in order to test and verify their protocol correctness and efficiency to meet actual environment of deployment system.

- properties cover
	- number of token can be carried
	- number of token can be placed on a same spot
	- life time of token

1. what properties are covered
2. why these were picked and important
3. how these properties effect the simulation and user
4. case study

\begin{description}
\item[Number of Token that agent can carry]
Token is only means for communication between agents, therefore number of tokens that agent can carry may impact the capability of computing of this model.

Since token is a piece of data that requires memory space for agent to store, therefore, the more tokens agent carries is the more space the agent has to allocate. Due to the nature to distributed mobile agent which the agent is small and limited computing power therefore the number of token that agent can carry is an important factor to consider when developing a protocol.

The simulation provide an option for user to specify the number of token in graph properties view, once the simulation is started the implementation underneath will assign tokens to each agent with a given max amount. The simulation provides API for user to access token information of an agent (e.g. number of token can be carried, current token holding etc.) so that user protocol can keep track of the using token. Also the simulation provides API access number of token currently resites at a node that agent currently resite as well.

For example ???

\item[Number of token that can be placed at a same location]
A location, node, can have finite number of token to be placed. However, currently DisJ simulation support unlimited number of token can be placed at a same location.

In order to solve problems with identical and indistinguishable token in this model, number of token becomes a vital property in term of communication such as placing particular number of tokens at particular location may means difference. Therefore, a capability of adjusting number of token can be placed at the same location might be very useful for developing and testing protocol.

Since DisJ currently does not support this property adjusting and leave it for future development, therefore, the number of token that can be placed at a same location is unlimited.

\item[Life Time of Token]
A token has a life time that it can be once it has been placed at a node. However, currently DisJ simulation support life time of token is infinite until the end of simulation.

A token that has been placed in a node requires memory space from a node. Since memory of a node is also limited, Therefore, a node may reclaim the memory back or there are others agents require to place tokens at the node as well but the memory space is limited. Therefore, a life time of token is also another option requires beside limit number of token can placed at a same location since some token may stay and never been used nor pick up.

DisJ simulation currently support only unlimited life time of token until the end of the simulation execution.




\subsection{RUNTIME}
This section discusses about two main components during runtime of the simulation, playback and adversary control
1. what is runtime and adversary control
2. what is it for
3. why need it

(in subsection)
4. what are the feature that supported
5. how the simulation support it

During DisJ simulation excuse a protocol that there are two main inputs, network topology and protocol (Java code) that drive behaviors of the simulation and results. During the simulation execution there are many things happening and sometime user wants to interrupt the execution in order to observe information and/or deviate some actions. Therefore, the simulation provides two types of interaction from user toward the simulation in runtime, playback and adversary interruption.

Playback is more of visualization tools that allows user to play, pause, and stop etc so that user can have a closer look and able to observe information at particular point of time instead of wait until the end and able to observe only a final results and status of the simulation.

Adversary control is an internal library that delegates between the simulation engine and user adversary instruction (codes), this codes allow user internally control behaviors of the executions to be in the way user wants without breaking rules or protocol. The adversary codes is just another Java codes that the simulation will intercept and inject into the simulation execution when it is needed, the detail are discussed in the following sub sections.


\subsubsection{Playback}

Playback of the simulation is a visualization tools that displays the changes of states of network and entities that user provided,through graph editor, before the execution starts. During the execution of the protocol, user can visually observe the changes on screen like the change of node state, agent states and location, and the value of curtain variable changed etc. The following subsections discuss a list of functionalities of playback that the simulation supports.

- functionalities support
	- play/pause/stop/step
	- statistic and graph display
	- record data into persistence storage

1. what feature is it
2. why this was picked and important
3. how this feature effect the simulation and user

\begin{description}
\item[Play-Pause-Stop]
  are common functionalities for any playback application that allow user to control the playback actions such as start or continue playing, pause currently playing and stop current playing, each of it details are discussed below

\begin[enumerate]
\item[Play]
This function makes the simulation to start or continue execution user protocol on a give topology; the Play command can be issued via GUI button and menu shown in graph editor. When the simulation is under play mode there are several things working such as new event has been generating and executed, screen keep updating visual information, logging system does recording necessary data into a persistence storage etc.

\item[Pause]
This function allows user to pause the simulation, all activities of every simulation subsystem will be put on hold; the Pause command can be issued via GUI button and menu  shown in graph editor. This function allows user to observe and investigate some values and status of the simulation with ease such as state of node and agent, raw record of activities (number of message, token, agent etc.) and progress of the protocol execution. In order to resume (continue) an execution, the user must issue a Play command again.

\item[Stop]
This function stop the simulation execution process regardless of the progress and state of the protocol execution. There are two ways of issue Stop command via GUI button and menu, another way is close down a graph editor tab of processing graph. The first will end the simulation normally while the later does not but neither will effect the simulation engine or user protocol, the only thing get effect is a replay record file(.rec) that will not have a complete record since it has bee stopped before the simulation is ended, unless the stop command is issued after the simulation end.
\end[enumerate]

\item[Statistic reports]
DisJ simulation provides simple reports during the playback in different form such as bar charts, property sheet, table columns and console text output. These data are very basic and important information that can be retrieve and understand quickly such as current states, location of agent, number of message sent/received, number of node, number of agent, token count etc.

\item[Persistence data log]
The Persistence data log is more like an internal function of the simulation which it main task is to save all necessary information of an execution in order to reproduce a visualization for a Replay function. The logging subsystem has two steps of logging, first capture event information such as timestamp, states and environment information etc. Second, constructs information obtained from the first step into a simple text format that Replay module understands, and record into persistence storage (e.g. file I/O).


\subsubsection{Adversary Control}

- Adversary interruptions
	- overview (objective, design, in action)

1. what is adversary
2. what is it for
3. why need it
4. how the simulation support it
5. how it has been designed and developed
6. why it has been done these ways, advantage/disadvantage
7. what another alternative of doing this
8. why we don't do as alternative way

Adversary Control is another mechanism that DisJ simulation provides for user to validate and verify the correctness of protocol. Since the simulation does not provide a GUI for user to change or update information of objects during the execution of protocol. Therefore, adversary control is another option that user may use it to interrupt and dictate how the simulation execute the protocol.

The adversary control module is a module that delegates between user adversary scripts(Java codes) and the simulation internal execution. The simulation has defined mapping table between internal communication function calls and the module scripts API. The mapping table will be used when an internal call has been invoked (by the simulation), first the mapping table will redirected the call to the module in order to check user adversary script whether there is any instruction related to this call. If there is, the simulation will perform the function call with given parameters from the script, otherwise it will use the simulation default configuration parameters.

However, this feature requires user to write a script in Java language by implementing the module functions which it will be used as adversary to verify and test the protocol. The module supports some basic and common controller such as arrival control, initiate control, time control and lost control.

\begin[enumerate]
\item[Arrival Control]
This allows adversary to control and dictate message or agent conditions (e.g. modified contents, reorder of arrival etc) when it arrives at target destination.

\item[Initiate Control]
This allows adversary to control and dictate time and condition when entities should be initiated.

\item[Time Control]
This allows adversary to control and dictate delay time of arrival of message or agent on target link.

\item[Lost Control]
This allows adversary to control and specify any message or agent to be lost in transmission on target link.
\end[enumerate]

The module also provide special API to adversary to access necessary infrastructure information of the simulation such as a list of all agents and nodes ID in the graph, get current time of the simulation, get all ports of a node etc. This API allows adversary to know and plan in advance of how to code adversary scripts that will verify and test a protocol correctly, an example will be described in appendix section.


- limitation

1. what are limitations
2. why it is limited
3. how to overcome

Limitation

The adversary control is double swards feature that may break the protocol even the protocol is actually correct since it can change decision making of the protocol and its behaviors. Therefore, the use of this feature is highly recommended to be very cautious.

In addition, an adversary script is fixed to a protocol and a graph since the script needs to know information of graph and protocol in order to verify it. Therefore, a script may or may not work on different combination of protocol and graph.

The priority of adversary interruption API is also important for user to keep in mind since at curtain time may be there are more than one functions were executed. At current implementation, the higher priority function that was executed will override the lower priority function if there is an overlapping of state or data change. Therefore, it is up to the user to keep in mind and check the list of API function calls priority. (double check ????)






\subsection{API}

1. what is communication protocol api
2. why do we need it
3. what does it help to make the simulation better
4. what group of api do we have here
5. what else we didn't cover here and why
6. how are we organize it here

\subsubsection{3.4.1 Communication Protocol}
This section describes interesting API and usage for user to use in communication between entities. The simulation supports three models message passing, mobile agent with black/whiteboard and mobile agent with token. The API is a most important tools that encapsulates underneath communication implementation that tie to many proprietary and specific technologies but serve the same purpose, which this allows user to focus on an actual protocol rather than coding and handling of those communication technologies. In this section we discuss some detail of interesting API of difference models and entities.


1. what are api for xxx
2. why do we need it, what benefit
3. what else we didn't cover
4. why this is enough
5. how is it works
6. examples

3.4.1.1 Node

- init() is an initiation function of a protocol. Once the simulation started, the first thing that the simulation will do is to execute init() of initiation node(s), where it (initiation node(s)) has been set by user in Graph Editor before starting the simulation. There must be at lest one node set to be an initiation node in order to activate a simulation of user protocol, and the function will be executed only once in a life time of the simulation, also the only node that set as initiation node will be executed with this function.

- become(int state) is a setting function that set a state of a node to be a prefer state. The state of a node represented by an integer number defined by user in a protocol, the number has to map to a color setting in Graph Editor as well in order to the simulation makes a correct virtualization (see 3.5 User Simulation GUI)

- getState() is a query function that returns a current state of a node.

- getTime() is a query function that returns a current simulation time.

- getName() is a query function that returns a name represented to a node. The name can be edited by user in Graph Editor before the starting of the simulation but it cannot be changed once the simulation is started.

- getXLocation() is a query function that return a current X coordinate of a node located in Graph Editor.

- getYLocation() is a query function that return a current Y coordinate of a node located in Graph Editor.

- alarmRing() is an internal alarm clock of a node that will interrupt a node when the setting time is reached. The alarm can be set by calling setAlarm() function.

- setAlarm(int timeUnit) is a setting function that set an internal clock of a node to be rang after a given (positive) unit of simulation time.

- getUserInput() is a query function that allows user to access a specific input (in String format) that user provided to a node via Graph Editor before or/and during the execution of the protocol.

- getInPorts() is a query function that returns a list of all incoming ports label of a node.

- getOutPorts() is a query function that returns a list of all outgoing ports label of a node.


3.4.1.2 Agent

- init() is an initiation function of a protocol. Once the simulation started, the first thing that the simulation will do is to execute init() of initiation agent(s), where it (initiation agent(s)) has been set by user in Graph Editor before starting the simulation. There must be at lest one agent set to be an initiation agent in order to activate a simulation of user protocol, and the function will be executed only once in a life time of the simulation, also the only agent that set as initiation agent will be executed with this function.


- become(int state) is a setting function that set a state of an agent to be a prefer state. The state of an agent represented by an integer number defined by user in a protocol, the number has to map to a color setting in Graph Editor as well in order to the simulation makes a correct virtualization (see 3.5 User Simulation GUI)

- getState() is a query function that returns a current state of an agent.

- alarmRing() is an internal alarm clock of an agent that will interrupt the agent when the setting time is reached. The alarm can be set by calling setAlarm() function.

- setAlarm(int timeUnit) is a setting function that set an internal clock of an agent to be rang after a given (positive) unit of simulation time.

- moveTo(String port) is a function that directs an agent to move into a given outgoing port of a current node that it resides.

- getAllInfo() is a query function that return a list data (in String format) that has been kept by an agent in memory slots. The number of memory slot is fixed by user via Graph Editor before starting the simulation, but the size of each slot is, currently, unlimited size of Java String.

- getInfo(int index) is a query function that return a data (in String format) corresponding to a given slot index that has been stored by an agent in memory slots.

- recordInfo(int index, String info) is a function that allows agent to add/override data at a given memory slot. The agent can erase data in a given slot index by add an empty String or null.

- getMaxSlot() is a query function that provides a maximum number of memory slot that agent available to keep information.

- getHostId() is a query function that return a current host ID that an agent currently located in Graph Editor.

3.4.1.3 Message passing

-	send() is a set of sending functions that allow a node to send message(s) to other nodes that directly connected to. The example of sending function are as follow

o	sendToAll() allows a same message to be send to all outgoing ports of a node at the same time.

o	sendToOthers() is for bi-directional link which allows a same message to be send to all ports of a node at the same time except a latest port that it received a message.

o	sendTo() is basic sending message that allow a node to send a message to all given target ports at the same time.

 The message types that can be passed through these functions parameter are Java primitive types and Serializable objects.

- receive(String port, IMessage message) is an entry point of receiving message of a node. The function provides port label of arrival and a message itself. IMessage is a wrapper object that allows user to get message label (if exist), by calling getLabel(), and actual message content, by calling getContent(), that a sender is sending.


3.4.1.4 Whiteboard

The board contains a list of slot and each slot represents Java String record written by an agent at each time. The number of slot defined by user at Graph Editor before the simulation starts, once the simulation started the number of slot cannot be modified. Any new record entering will append to the end and if the number of record exceed the limit size of slot, the oldest record will be removed and new record will be append to the end of slot.

Synchronous of data will be handled in such a way that there is only one physical memory of board for all agents.

Example1, a board contains two records; an agent 'A' is reading from the board and currently is at record number two. At the same time an agent 'B' is appeding a new record to the board and finished it before agent 'A' done reading number two record. Once an agent 'A' done reading record number two, agent 'A' will read be able to see and read record number three. However, if agent 'A' done reading number two record before agent 'B' done writing record three, then agent 'A' will not the record number three.

Example2, a board contains three records; an agent 'A' is reading from the board and currently reading record number two. At the same time an agent 'B' is removing record number one, regardless of whoever done first between 'A' and 'B', agent 'A' will never known that the record number one has been removed unless agent 'A' starts reading the board again. However, if agent 'B' is removing record number three, and 'B' done removing the record number three before 'A' done reading the record number two, then 'A' will not see the record number three, otherwise 'A' will see record number three.

- readFrom() is a function called by an agent in order to read from a board at a current host node. The function will return a current list of record in a list of String format..  (How an agent object can access data of a node object???)

- writeTo(String info) is a function called by an agent in order to write a record into a board of a current host node. The size of the record for each call (slot), currently, is unlimited size of Java String. The new entering record will be append to the end of the board, if the number of slot exceed the limit, the oldest slot will be removed and a new record will be appended to the end of a board.

- remove(String info) is a function called by an agent in order to remove a record ,corresponding to a given data entry, from a board at a current host node.


3.4.1.5 Token

- countMyToken() is a query function that return a number of token that an agent currently has.

- countHostToken() is a query function that return a number of token that currently located in a host node that agent resides.

- dropToken() is a function that allows an agent to leave a token at a current host node.

- pickupToken() is a function that allows an agent to pick up a token at a current host node.

- getMaxToken() is a query function that returns a number of maximum token that an agent can carry.

- replicateToken() (do we need it now???)
- destroyToken()(do we need it now???)

\subsubsection{3.4.2 Underline Libraries TODO ????}
This section discuss about main and interesting libraries used by the system
1. what is underline libraries
2. why do we need it
3. what does it help to make the simulation better
4. what group of underline libraries do we have here
5. what else we didn't include here, and why
6. how are we organize it here



\subsubsection{3.4.2.1 Probability Libraries Extensions}
1. what is probability lib
2. why do we need it, what benefit
3. what else we didn't cover
4. why this is enough
3. how is it works
4. examples



\subsubsection{3.4.3 External (Adversary) Interrupts}
This section describes interesting API and usage for user to implement their own protocol
1. what is adversary
2. why do we need it
3. what does it help to make the simulation better
4. what functionality we cover here for adversary
5. what else we didn't include here, and why
6. how are we organize it here


3.4.3.1 Node

- init(Node n) the function allows user to control the time and conditions of a node initialization. The user will be able to observe node states and information and return true if a node requires an execution otherwise return false.

- delay_arrival(Node n) the function that allows user to delay message/agent from any port that will arrive at node n. The user will be able to access every port of node n, include observing messages/agents that are arriving. The user can hold any arriving messages/agent at any port of n by setting timeout in finite unit of simulation time.

- alarm(Node n) the function allows user to specify a node to perform some certain action after it has been initialized at specific time. The user can specify a simulation time or conditions of a node in order to perform some tasks. This function will be executed when the time has arrived or when the node received a message.

- order_msg(Node m, Node n) the function allows user to control the order of message sending from node 'm' to node 'n' in any order (based on user implementation in this function). This function will be called when 'm' send message to 'n'.


- initialize target condition
- initialize time condition
- wake up condition

1. what are api for node
2. why do we need it, what benefit
3. how it works (underline system)
4. what else we didn't cover
5. why this is enough
6. how to use it
7. examples


3.4.3.2 Agent

- init(Agent a) the function allows user to control the time and conditions of an agent initialization. The user will be able to observe agent information, and return true if an agent requires an execution otherwise return false.

- alarm(Agent a) the function allows user to specify an agent to perform some certain action after it has been initialized at specific time. The user can specify a simulation time or conditions of an agent in order to perform some tasks. This function will be executed when the time has arrived.

- move(Agent a) the function allows user to control direction of agent movement. The user will be able to access agent states and location and specify the direction of agent next move. However, it is a responsible for user to make sure that it does not break the protocol. This function will be called when agent about to move.
	
- order_move_in(Agent a) this function allows user to control an agent when it tries to enter a node. Before an agent entering a node, this function will be called and user able to hold agent in front of the node with a specific time or under conditions (based on user implementation in this function) by returning true it will enter the node otherwise false.

- order_move_out(Agent a) this function allows user to control an agent when it tries to leave a node. Before an agent leaving a node, this function will be called and user able to hold agent inside a node with a specific time or under conditions (based on user implementation in this function) by returning true it will leave the node otherwise false.


- initialize target condition
- initialize time condition
- wake up condition
- move to target condition
- arrive time at target condition

1. what are api for agent
2. why do we need it, what benefit
3. how it works (underline system)
4. what else we didn't cover
5. why this is enough
6. how to use it
7. examples


Limitation

Since some function calls are called by the simulation at the same conditions therefore, the following is a list adversary API function calls priority and order. (??? Priority based on the order of who call first, the first will be override by the later)

-TODO list of priority ?????

3.5 USER SIMULATION (HCI and GUI) TODO ???
This section discuss why the system interface has been layout the way it is

\subsection{STATISTIC AND REPORT}
This section discuss about representation of statistic data collected during the execution of algorithm

3.6.1 Topology Overall

- Number of nodes in a network ' GP
- Number of links in a network ' GP
- Number of agents at the start of the simulation ' GP
- Number of currently agents alive ' GP
- Maximum number of tokens that an agent can carry ' GP

3.6.2 Node
- A list of nodes with a state at the end of simulation ' NV
- A list of nodes with a sequence of state transition ' NP
- A list of nodes with a total number of agents visited ' C

3.6.3 Agent
- A list of alive agents ' AV
- A list of agents with a state at the end of simulation ' C
- A list of agents with a sequence of state transition ' AV
- A list of agents with a number of moves at the end of simulation ' C
- A list of states with number of moved of all agents at the end of simulation  ' C

+A bar chart represents agent states verses number of agents
+A bar chart represents agent states verses number of move made by agents


3.6.4 Message
- A total number of messages have been sent ' GP
- A total number of messages have been received ' GP
- A list of message types with number of produced (sent) ' C
- Node(s) that has a highest load of received/sent message (include node info) 'C
- Node(s) that has a lowest load of received/sent message (include node info) 'C

+A graph represents a number message produced in every period of time T unit

+A bar chart represents node states verses number of nodes (in that state)
+A bar chart represents node states verses accumulation of number of messages produced during such states

3.6.5 Blackboard/Whiteboard
- A total number of times that (all) boards have been accessed ' C
- A total number of write accesses to every board ' C
- A total number of delete accesses to every board ' C
- A total number of read accesses to every board ' C
- Board(s) that has a highest number of write accesses (include node info) ' C
- Board(s) that has a lowest number of write accesses (include node info) ' C
- Board(s) that has a highest number of read accesses (include node info) ' C
- Board(s) that has a lowest number of read accesses (include node info) ' C

3.6.6 Token
- A total number of tokens that have been dropped by all agents ' C
- A total number of tokens that have been picked up by all agents 'C
- A list of agents with number of current tokens holding ' AV
- A list of nodes with a total number of tokens that have been dropped  ' C
- A list of nodes with a total number of tokens that have been picked ' C

- Agent(s) that has a highest number of pick up token ' C
- Agent(s) that has a lowest number of pick up token ' C
- Agent(s) that has a highest number of drop off token ' C
- Agent(s) that has a lowest number of drop off token ' C
- A highest number of tokens have been dropped at a node ' C

+A bar chart represents agent state verses number of pick up token
+A bar chart represents agent state verses number of drop off token

3.6.7 Edge
- An average accumulated delay time of all edges at the end of simulation ' C
- Edge(s) that has a highest accumulate delay time (include edge info) ' C
- A total number of message/agent entering each edge ' EP
- A total number of message/agent leaving each edge ' EP
